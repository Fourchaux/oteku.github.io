<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta http-equiv="content-type" content="text/html; charset=utf-8" />

    <!-- Enable responsiveness on mobile devices-->
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1"
    />

    <title>Les carnets d&#x27;Oteku</title>
    <link rel="icon" type="image/png" href="favicon.ico" />
    <!-- CSS -->
    <link rel="stylesheet" href="https:&#x2f;&#x2f;oteku.github.io&#x2f;print.css" media="print" /> <link rel="stylesheet" href="https:&#x2f;&#x2f;oteku.github.io&#x2f;poole.css" /> <link rel="stylesheet" href="https:&#x2f;&#x2f;oteku.github.io&#x2f;hyde.css" /> <link rel="stylesheet" href="https:&#x2f;&#x2f;oteku.github.io&#x2f;fontawsome.css" />
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Special+Elite"
    />

     <link rel="alternate"
    type="application/rss+xml" title="RSS" href="https:&#x2f;&#x2f;oteku.github.io&#x2f;rss.xml" />   
  </head>

  <body
    class="theme-base-0b layout-reverse"
  >
    
    <div class="sidebar">
      <div
        class="container sidebar-sticky"
      >
        <div class="sidebar-about">
          
          <a href="https:&#x2f;&#x2f;oteku.github.io"
            ><h1>Les carnets d&#x27;Oteku</h1></a
          >
          
          <p class="lead">Je m&#x27;appelle Thomas Haesslé, j&#x27;écris quelques essais dans ce carnet sur #ReasonML #OCaml #Rust</p>
           
        </div>

        <ul class="sidebar-nav">
           
          <li class="sidebar-nav-item">
            <i
              class="icon-twitter"
              ><a href="https:&#x2f;&#x2f;twitter.com&#x2f;oteku">Twitter</a></i
            >
          </li>
          
          <li class="sidebar-nav-item">
            <i
              class="icon-link"
              ><a href="https:&#x2f;&#x2f;mastodon.social&#x2f;@oteku">Mastodon</a></i
            >
          </li>
          
          <li class="sidebar-nav-item">
            <i
              class="icon-github"
              ><a href="https:&#x2f;&#x2f;github.com&#x2f;oteku">Github</a></i
            >
          </li>
          
          <li class="sidebar-nav-item">
            <i
              class="icon-beer"
              ><a href="https:&#x2f;&#x2f;www.meetup.com&#x2f;fr-FR&#x2f;Lille-FP">LilleFP</a></i
            >
          </li>
          
          <li class="sidebar-nav-item">
            <i
              class="icon-rss"
              ><a href="rss.xml">Flux rss</a></i
            >
          </li>
          
          <hr />
          <li class="sidebar-nav-item">
            <i class="icon-gift">
              Merci <a href="https://www.getzola.org/">Zola</a> pour ce site</i
            >
          </li>
          
        </ul>
      </div>
    </div>
    

    <div class="content container">
      
<div class="post">
  <h1 class="post-title">Opérateur pipe en Rust ?</h1>
  <span class="post-date">2019-03-29</span>
  <p>L'absence d'opérateur de composition, similaire au <code>.</code> de Haskell, ou de pipeline similaire au <code>|&gt;</code> de ReasonML et OCaml, est assez frustrante lors qu'on essaie de faire du code Rust déclaratif.</p>
<p>Il est possible d'envisager la <em>dot notation</em> mais d'une part ce n'est pas totalement satisfaisant et d'autre part cela nécessite d'implémenter des traits pour chacun des types de données qui composent le flux de traitement.</p>
<p>Heureusement la programmation générique et les macros de <strong>Rust</strong> peuvent nous aider à implémenter la composition assez facilement :</p>
<pre style="background-color:#212733;">
<span style="color:#ccc9c2;">
</span><span style="font-style:italic;color:#5c6773;">// function used to compose
</span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">compose_two</span><span style="color:#ccc9c2;">&lt;A, B, C, G, F&gt;(</span><span style="color:#ffcc66;">f</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> F, </span><span style="color:#ffcc66;">g</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> G) </span><span style="color:#ccc9c2cc;">-&gt;</span><span style="color:#ccc9c2;"> impl FnOnce(A) </span><span style="color:#ccc9c2cc;">-&gt;</span><span style="color:#ccc9c2;"> C
</span><span style="color:#ffa759;">where</span><span style="color:#ccc9c2;">
    F</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> FnOnce(A) -&gt; B,
    G</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> FnOnce(B) -&gt; C,
{
    </span><span style="color:#ffa759;">move </span><span style="color:#f29e74;">|</span><span style="color:#ccc9c2;">x</span><span style="color:#f29e74;">| </span><span style="color:#f28779;">g</span><span style="color:#ccc9c2;">(</span><span style="color:#f28779;">f</span><span style="color:#ccc9c2;">(x))
}

</span><span style="font-style:italic;color:#5c6773;">// composition macro
</span><span style="color:#f28779;">macro_rules! </span><span style="color:#73d0ff;">compose </span><span style="color:#ccc9c2;">{
    ( </span><span style="color:#ffcc66;">$last</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ffa759;">expr </span><span style="color:#ccc9c2;">) </span><span style="color:#f29e74;">=&gt; </span><span style="color:#ccc9c2;">{ $last };
    ( </span><span style="color:#ffcc66;">$head</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ffa759;">expr</span><span style="color:#ccc9c2;">, </span><span style="color:#f29e74;">$</span><span style="color:#ccc9c2;">($tail:expr), +) =&gt; {
        compose_two($head, compose!($($tail),</span><span style="color:#f29e74;">+</span><span style="color:#ccc9c2;">))
    };
}
</span></pre>
<p>Maintenant on peut composer des fonctions ainsi :</p>
<pre style="background-color:#212733;">
<span style="color:#ffa759;">fn </span><span style="color:#ffd580;">main</span><span style="color:#ccc9c2;">() {
    </span><span style="color:#ffa759;">let </span><span style="color:#ffd580;">double </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">|</span><span style="color:#ffcc66;">x</span><span style="color:#ccc9c2;">| x </span><span style="color:#f29e74;">* </span><span style="color:#ffcc66;">2</span><span style="color:#ccc9c2cc;">;
    </span><span style="color:#ffa759;">let </span><span style="color:#ffd580;">add2 </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">|</span><span style="color:#ffcc66;">x</span><span style="color:#ccc9c2;">| x </span><span style="color:#f29e74;">+ </span><span style="color:#ffcc66;">2</span><span style="color:#ccc9c2cc;">;
    </span><span style="color:#ffa759;">let</span><span style="color:#ccc9c2;"> double_then_add2 </span><span style="color:#f29e74;">= </span><span style="color:#f28779;">compose!</span><span style="color:#ccc9c2;">(double</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;"> add2)</span><span style="color:#ccc9c2cc;">;
    </span><span style="color:#f28779;">println!</span><span style="color:#ccc9c2;">(</span><span style="color:#bae67e;">&quot;Result is </span><span style="color:#ffcc66;">{}</span><span style="color:#bae67e;">&quot;</span><span style="color:#ccc9c2cc;">, </span><span style="color:#f28779;">double_then_add2</span><span style="color:#ccc9c2;">(</span><span style="color:#ffcc66;">10</span><span style="color:#ccc9c2;">))</span><span style="color:#ccc9c2cc;">;
</span><span style="color:#ccc9c2;">}
</span></pre>
<p>Grâce à notre macro <code>compose!</code>, nous pouvons également créer une nouvelle macro <code>pipe!</code> :</p>
<pre style="background-color:#212733;">
<span style="color:#ccc9c2;">
</span><span style="font-style:italic;color:#5c6773;">// function needed to infer type
</span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">pipe_two</span><span style="color:#ccc9c2;">&lt;A, B, F&gt;(</span><span style="color:#ffcc66;">a </span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> A, </span><span style="color:#ffcc66;">f</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> F) </span><span style="color:#ccc9c2cc;">-&gt;</span><span style="color:#ccc9c2;"> B
</span><span style="color:#ffa759;">where</span><span style="color:#ccc9c2;">
    F</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> FnOnce(A) -&gt; B,
{
    </span><span style="color:#f28779;">f</span><span style="color:#ccc9c2;">(a)
}

</span><span style="font-style:italic;color:#5c6773;">// pipe macro
</span><span style="color:#f28779;">macro_rules! </span><span style="color:#73d0ff;">pipe </span><span style="color:#ccc9c2;">{
    ( </span><span style="color:#ffcc66;">$last</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ffa759;">expr </span><span style="color:#ccc9c2;">) </span><span style="color:#f29e74;">=&gt; </span><span style="color:#ccc9c2;">{ $last };
    ( </span><span style="color:#ffcc66;">$head</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ffa759;">expr</span><span style="color:#ccc9c2;">, </span><span style="color:#f29e74;">$</span><span style="color:#ccc9c2;">($tail:expr), +) =&gt; {
        pipe_two($head, compose!($($tail),</span><span style="color:#f29e74;">+</span><span style="color:#ccc9c2;">))
    };
}
</span></pre>
<p>Dorenavant nous pouvons directement pipeliner nos fonctions ainsi :</p>
<pre style="background-color:#212733;">
<span style="color:#ffa759;">fn </span><span style="color:#ffd580;">main</span><span style="color:#ccc9c2;">() {
    </span><span style="color:#ffa759;">let </span><span style="color:#ffd580;">double </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">|</span><span style="color:#ffcc66;">x</span><span style="color:#ccc9c2;">| x </span><span style="color:#f29e74;">* </span><span style="color:#ffcc66;">2</span><span style="color:#ccc9c2cc;">;
    </span><span style="color:#ffa759;">let </span><span style="color:#ffd580;">add2 </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">|</span><span style="color:#ffcc66;">x</span><span style="color:#ccc9c2;">| x </span><span style="color:#f29e74;">+ </span><span style="color:#ffcc66;">2</span><span style="color:#ccc9c2cc;">;
    </span><span style="color:#f28779;">println!</span><span style="color:#ccc9c2;">(</span><span style="color:#bae67e;">&quot;Result is </span><span style="color:#ffcc66;">{}</span><span style="color:#bae67e;">&quot;</span><span style="color:#ccc9c2cc;">, </span><span style="color:#f28779;">pipe!</span><span style="color:#ccc9c2;">(</span><span style="color:#f28779;">double</span><span style="color:#ccc9c2;">(</span><span style="color:#ffcc66;">10</span><span style="color:#ccc9c2;">)</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;"> add2))</span><span style="color:#ccc9c2cc;">;
    </span><span style="color:#f28779;">println!</span><span style="color:#ccc9c2;">(</span><span style="color:#bae67e;">&quot;Result is </span><span style="color:#ffcc66;">{}</span><span style="color:#bae67e;">&quot;</span><span style="color:#ccc9c2cc;">, </span><span style="color:#f28779;">pipe!</span><span style="color:#ccc9c2;">(</span><span style="color:#ffcc66;">10</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;"> double</span><span style="color:#ccc9c2cc;">,</span><span style="color:#ccc9c2;"> add2))</span><span style="color:#ccc9c2cc;">;
</span><span style="color:#ccc9c2;">}
</span></pre>
<p>Implémenter un opérateur infixe est un peu plus complexe parce que Rust limite les opérateurs surchargeables à certains opérateurs via le module <a href="https://doc.rust-lang.org/std/ops/index.html">std::ops</a>, malheureusement <code>|&gt;</code> n'en fait pas parti, cependant il est possible d'utiliser <code>|</code> ce qui nous rappelera le pipelining Linux.</p>
<p>Un autre point à prendre en compte est que nous avons besoin d'un type pour encapsuler nos données, si on veut éviter d'implémenter le trait <a href="https://doc.rust-lang.org/std/ops/trait.BitOr.html">BitOr</a> pour chaque type initiant un pipelining.</p>
<pre style="background-color:#212733;">
<span style="font-style:italic;color:#5c6773;">// Need a wrapper to implement pipe operator
</span><span style="color:#ffa759;">struct </span><span style="color:#73d0ff;">Scalar</span><span style="color:#ccc9c2;">&lt;T&gt;(T)</span><span style="color:#ccc9c2cc;">;

</span><span style="color:#ffa759;">use </span><span style="color:#ccc9c2;">std</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">ops</span><span style="color:#f29e74;">::</span><span style="color:#ccc9c2;">BitOr</span><span style="color:#ccc9c2cc;">;
</span><span style="color:#ffa759;">impl</span><span style="color:#ccc9c2;">&lt;A, B, F&gt; BitOr&lt;F&gt; </span><span style="color:#ffa759;">for </span><span style="color:#73d0ff;">Scalar</span><span style="color:#ccc9c2;">&lt;A&gt;
    </span><span style="color:#ffa759;">where</span><span style="color:#ccc9c2;"> F</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> FnOnce(A) -&gt; B
{
    </span><span style="color:#ffa759;">type </span><span style="color:#73d0ff;">Output </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">Scalar&lt;B&gt;</span><span style="color:#ccc9c2cc;">;

    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">bitor</span><span style="color:#ccc9c2;">(</span><span style="color:#ffcc66;">self</span><span style="color:#ccc9c2;">, </span><span style="color:#ffcc66;">f</span><span style="color:#ccc9c2cc;">:</span><span style="color:#ccc9c2;"> F) </span><span style="color:#ccc9c2cc;">-&gt; </span><span style="color:#ccc9c2;">Scalar&lt;B&gt; {
        Scalar(</span><span style="color:#f28779;">f</span><span style="color:#ccc9c2;">(</span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span style="color:#ffcc66;">0</span><span style="color:#ccc9c2;">))
    }
}

</span><span style="font-style:italic;color:#5c6773;">// Need an unwrapping function
</span><span style="color:#ffa759;">impl</span><span style="color:#ccc9c2;">&lt;T&gt; </span><span style="color:#73d0ff;">Scalar</span><span style="color:#ccc9c2;">&lt;T&gt; {
    </span><span style="color:#ffa759;">fn </span><span style="color:#ffd580;">unwrap</span><span style="color:#ccc9c2;">(</span><span style="color:#ffcc66;">self</span><span style="color:#ccc9c2;">) </span><span style="color:#ccc9c2cc;">-&gt;</span><span style="color:#ccc9c2;"> T{
        </span><span style="font-style:italic;color:#5ccfe6;">self</span><span style="color:#f29e74;">.</span><span style="color:#ffcc66;">0
    </span><span style="color:#ccc9c2;">}
}
</span></pre>
<p>Ce qui nous permet enfin d'écrire :</p>
<pre style="background-color:#212733;">
<span style="color:#ffa759;">fn </span><span style="color:#ffd580;">main</span><span style="color:#ccc9c2;">() {
    </span><span style="color:#ffa759;">let </span><span style="color:#ffd580;">double </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">|</span><span style="color:#ffcc66;">x</span><span style="color:#ccc9c2;">| x </span><span style="color:#f29e74;">* </span><span style="color:#ffcc66;">2</span><span style="color:#ccc9c2cc;">;
    </span><span style="color:#ffa759;">let </span><span style="color:#ffd580;">add2 </span><span style="color:#f29e74;">= </span><span style="color:#ccc9c2;">|</span><span style="color:#ffcc66;">x</span><span style="color:#ccc9c2;">| x </span><span style="color:#f29e74;">+ </span><span style="color:#ffcc66;">2</span><span style="color:#ccc9c2cc;">;
    </span><span style="color:#f28779;">println!</span><span style="color:#ccc9c2;">(</span><span style="color:#bae67e;">&quot;Result is </span><span style="color:#ffcc66;">{}</span><span style="color:#bae67e;">&quot;</span><span style="color:#ccc9c2cc;">, </span><span style="color:#ccc9c2;">(Scalar(</span><span style="color:#ffcc66;">10</span><span style="color:#ccc9c2;">) </span><span style="color:#f29e74;">|</span><span style="color:#ccc9c2;"> double </span><span style="color:#f29e74;">|</span><span style="color:#ccc9c2;"> add2)</span><span style="color:#f29e74;">.</span><span style="color:#f28779;">unwrap</span><span style="color:#ccc9c2;">())</span><span style="color:#ccc9c2cc;">;
</span><span style="color:#ccc9c2;">}
</span></pre>
<p>On peut donc conclure qu'avec peu de code boilerplate, il est relativement aisé de composer des fonctions en Rust. Pour ma part, je trouve qu'implémenter l'opérateur infixe amène une complexité supplémentaire, à cause de la nécessité de mettre en place les <em>wrapping</em> et <em>unwrapping</em>, c'est pourquoi je préfère utiliser les macros dans mon code.</p>

</div>

    </div>
  </body>
</html>
